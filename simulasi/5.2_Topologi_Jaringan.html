<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topologi Jaringan & Paket Switching</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX Transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons Core -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 10px;
        }
        svg text {
            user-select: none;
            -webkit-user-select: none;
            pointer-events: none;
        }
        /* Animasi alur data yang diperkuat visualnya */
        @keyframes dash-move {
            from {
                stroke-dashoffset: 24;
            }
            to {
                stroke-dashoffset: 0;
            }
        }
        .data-flow-line {
            stroke: #22d3ee; /* Warna Cyan Glowing */
            stroke-width: 4;
            stroke-dasharray: 12, 12;
            animation: dash-move 1s linear infinite;
            filter: drop-shadow(0 0 3px rgba(34, 211, 238, 0.8));
            pointer-events: none;
        }
        .packet-transition {
            transition: transform 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }
    </style>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        /**
         * Komponen Ikon UI (Tombol)
         */
        const UIIcon = ({ name, size = 20, color = "currentColor" }) => {
            const lucideIcons = window.lucide?.icons;
            if (!lucideIcons) return null;
            const iconData = lucideIcons[name] || lucideIcons[name.toLowerCase()] || lucideIcons[name.replace(/-/g, '')];
            if (!Array.isArray(iconData)) return null;
            const [tag, attrs, children] = iconData;
            return React.createElement(
                'svg',
                { ...attrs, width: size, height: size, stroke: color, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                children.map((child, index) => React.createElement(child[0], { ...child[1], key: index }))
            );
        };

        /**
         * HARDWARE ICONS (SVG PATHS)
         */
        const HardwareIcon = ({ type, color = "#64748b", size = 28 }) => {
            const paths = {
                pc: (
                    <g transform="translate(2,2) scale(0.85)">
                        <rect x="2" y="3" width="20" height="14" rx="2" ry="2" />
                        <line x1="8" y1="21" x2="16" y2="21" />
                        <line x1="12" y1="17" x2="12" y2="21" />
                    </g>
                ),
                router: (
                    <g transform="translate(2,2) scale(0.85)">
                        <rect x="4" y="4" width="16" height="16" rx="2" />
                        <rect x="9" y="9" width="6" height="6" />
                        <line x1="9" y1="1" x2="9" y2="4" /><line x1="15" y1="1" x2="15" y2="4" />
                        <line x1="9" y1="20" x2="9" y2="23" /><line x1="15" y1="20" x2="15" y2="23" />
                        <line x1="20" y1="9" x2="23" y2="9" /><line x1="20" y1="15" x2="23" y2="15" />
                        <line x1="1" y1="9" x2="4" y2="9" /><line x1="1" y1="15" x2="4" y2="15" />
                    </g>
                ),
                server: (
                    <g transform="translate(2,2) scale(0.85)">
                        <rect x="2" y="2" width="20" height="8" rx="2" ry="2" />
                        <rect x="2" y="14" width="20" height="8" rx="2" ry="2" />
                        <line x1="6" y1="6" x2="6.01" y2="6" /><line x1="6" y1="18" x2="6.01" y2="18" />
                    </g>
                )
            };
            return (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    {paths[type] || null}
                </svg>
            );
        };

        const TOPOLOGIES = { BUS: 'Bus', STAR: 'Star', RING: 'Ring', MESH: 'Mesh' };
        const MODES = { LAB: 'Topology Lab', PACKET: 'Packet Switching' };

        const App = () => {
            const [activeMode, setActiveMode] = useState(MODES.LAB);
            const [topology, setTopology] = useState(TOPOLOGIES.STAR);
            const [brokenElements, setBrokenElements] = useState(new Set());
            const [isSimulating, setIsSimulating] = useState(false);
            const [packets, setPackets] = useState([]);
            const [routerStatus, setRouterStatus] = useState({});
            const [routerLoad, setRouterLoad] = useState({});

            useEffect(() => {
                const initialStatus = {}; const initialLoad = {};
                for(let i=1; i<=12; i++) { initialStatus[i] = true; initialLoad[i] = 0; }
                setRouterStatus(initialStatus); setRouterLoad(initialLoad);
            }, []);

            // Titik center ditinggikan dari 250 ke 200
            const topologyData = useMemo(() => {
                const nodes = []; const edges = []; const center = { x: 400, y: 200 }; const radius = 160;
                switch (topology) {
                    case TOPOLOGIES.STAR:
                        nodes.push({ id: 'hub', x: center.x, y: center.y, type: 'server', label: 'HUB' });
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI) / 5;
                            const nodeId = `n${i}`;
                            nodes.push({ id: nodeId, x: center.x + radius * Math.cos(angle), y: center.y + radius * Math.sin(angle), type: 'pc', label: i === 0 ? 'A' : i === 1 ? 'B' : String.fromCharCode(67 + i - 2) });
                            edges.push({ id: `e${i}`, from: 'hub', to: nodeId });
                        }
                        break;
                    case TOPOLOGIES.RING:
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 2 * Math.PI) / 6;
                            const nodeId = `n${i}`;
                            nodes.push({ id: nodeId, x: center.x + radius * Math.cos(angle), y: center.y + radius * Math.sin(angle), type: 'pc', label: i === 0 ? 'A' : i === 1 ? 'B' : String.fromCharCode(67 + i - 2) });
                        }
                        for (let i = 0; i < 6; i++) edges.push({ id: `e${i}`, from: `n${i}`, to: `n${(i + 1) % 6}` });
                        break;
                    case TOPOLOGIES.BUS:
                        nodes.push({ id: 'backbone', isBackbone: true });
                        for (let i = 0; i < 6; i++) {
                            const x = 150 + i * 100;
                            const nodeId = `n${i}`;
                            nodes.push({ id: nodeId, x, y: i % 2 === 0 ? 80 : 320, type: 'pc', label: i === 0 ? 'A' : i === 1 ? 'B' : String.fromCharCode(67 + i - 2) });
                            edges.push({ id: `e${i}`, from: `bus${i}`, to: nodeId, busX: x, busY: 200 });
                            if (i > 0) edges.push({ id: `bseg${i}`, from: `bus${i-1}`, to: `bus${i}`, isBackboneSeg: true });
                        }
                        break;
                    case TOPOLOGIES.MESH:
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI) / 5;
                            const nodeId = `n${i}`;
                            nodes.push({ id: nodeId, x: center.x + radius * Math.cos(angle), y: center.y + radius * Math.sin(angle), type: 'pc', label: i === 0 ? 'A' : i === 1 ? 'B' : String.fromCharCode(67 + i - 2) });
                        }
                        let eIdx = 0;
                        for (let i = 0; i < 5; i++) for (let j = i + 1; j < 5; j++) edges.push({ id: `e${eIdx++}`, from: `n${i}`, to: `n${j}` });
                        break;
                }
                return { nodes, edges };
            }, [topology]);

            const isLabConnected = useCallback(() => {
                if (brokenElements.has('n0') || brokenElements.has('n1')) return false;
                if (topology === TOPOLOGIES.STAR && brokenElements.has('hub')) return false;
                if (topology === TOPOLOGIES.BUS && brokenElements.has('backbone')) return false;

                const adj = {};
                topologyData.edges.forEach(e => {
                    if (brokenElements.has(e.id)) return;
                    if (!adj[e.from]) adj[e.from] = []; if (!adj[e.to]) adj[e.to] = [];
                    adj[e.from].push(e.to); adj[e.to].push(e.from);
                });

                const visited = new Set(); const queue = ['n0'];
                while (queue.length > 0) {
                    const curr = queue.shift();
                    if (curr === 'n1') return true;
                    if (!visited.has(curr)) { visited.add(curr); (adj[curr] || []).forEach(n => { if (!brokenElements.has(n)) queue.push(n); }); }
                }
                return false;
            }, [topologyData, brokenElements, topology]);

            const packetNodes = useMemo(() => [
                { id: 1, x: 80, y: 180, label: 'Src', type: 'pc' },
                { id: 2, x: 200, y: 100, label: 'R1', type: 'router' }, { id: 3, x: 200, y: 300, label: 'R2', type: 'router' },
                { id: 4, x: 350, y: 50, label: 'R3', type: 'router' }, { id: 5, x: 350, y: 180, label: 'R4', type: 'router' }, { id: 6, x: 350, y: 310, label: 'R5', type: 'router' },
                { id: 7, x: 500, y: 50, label: 'R6', type: 'router' }, { id: 8, x: 500, y: 180, label: 'R7', type: 'router' }, { id: 9, x: 500, y: 310, label: 'R8', type: 'router' },
                { id: 10, x: 650, y: 100, label: 'R9', type: 'router' }, { id: 11, x: 650, y: 300, label: 'R10', type: 'router' },
                { id: 12, x: 730, y: 180, label: 'Dst', type: 'pc' },
            ], []);

            const packetEdges = [
                { from: 1, to: 2 }, { from: 1, to: 3 }, { from: 2, to: 4 }, { from: 2, to: 5 }, { from: 3, to: 5 }, { from: 3, to: 6 },
                { from: 4, to: 7 }, { from: 5, to: 7 }, { from: 5, to: 8 }, { from: 6, to: 8 }, { from: 6, to: 9 },
                { from: 7, to: 10 }, { from: 8, to: 10 }, { from: 8, to: 11 }, { from: 9, to: 11 }, { from: 10, to: 12 }, { from: 11, to: 12 },
                { from: 2, to: 3 }, { from: 4, to: 5 }, { from: 5, to: 6 }, { from: 7, to: 8 }, { from: 8, to: 9 }, { from: 10, to: 11 }
            ];

            const toggleRouter = (id) => { if (id === 1 || id === 12) return; setRouterStatus(prev => ({ ...prev, [id]: !prev[id] })); };

            const findAdaptivePath = (start, end, currentLoads) => {
                const queue = [{ node: start, path: [start], cost: 0 }];
                const visited = new Map(); let bestPath = null; let minCost = Infinity;
                while (queue.length > 0) {
                    queue.sort((a, b) => a.cost - b.cost);
                    const { node, path, cost } = queue.shift();
                    if (node === end) { if (cost < minCost) { minCost = cost; bestPath = path; } continue; }
                    if (!visited.has(node) || visited.get(node) > cost) {
                        visited.set(node, cost);
                        const neighbors = packetEdges.filter(e => e.from === node || e.to === node).map(e => (e.from === node ? e.to : e.from)).filter(n => routerStatus[n]);
                        for (const neighbor of neighbors) {
                            const loadPenalty = (currentLoads[neighbor] || 0) * 10;
                            queue.push({ node: neighbor, path: [...path, neighbor], cost: cost + 1 + loadPenalty + Math.random() * 0.2 });
                        }
                    }
                }
                return bestPath;
            };

            const startPacketSimulation = async () => {
                if (isSimulating) return; setIsSimulating(true);
                setPackets(Array.from({ length: 8 }, (_, i) => ({ id: i + 1, currentPos: packetNodes.find(n => n.id === 1), status: 'queued', hops: 0, delay: i * 1, history: [1] })));
                let currentStep = 0;
                const simInterval = setInterval(() => {
                    setPackets(prev => {
                        const currentLoads = {}; for(let i=1; i<=12; i++) currentLoads[i] = 0;
                        prev.forEach(p => { if (p.status === 'moving') currentLoads[p.currentPos.id]++; });
                        setRouterLoad(currentLoads);
                        const nextState = prev.map(p => {
                            if (p.status === 'arrived' || p.status === 'dropped') return p;
                            if (p.status === 'queued') return currentStep >= p.delay ? { ...p, status: 'moving' } : p;
                            const currentId = p.currentPos.id; if (currentId === 12) return { ...p, status: 'arrived' };
                            const targetPath = findAdaptivePath(currentId, 12, currentLoads);
                            if (!targetPath || targetPath.length < 2) return { ...p, status: 'dropped' };
                            const nextNodeId = targetPath[1];
                            return { ...p, currentPos: packetNodes.find(n => n.id === nextNodeId), hops: p.hops + 1, history: [...p.history, nextNodeId] };
                        });
                        if (nextState.every(p => p.status === 'arrived' || p.status === 'dropped')) { clearInterval(simInterval); setIsSimulating(false); }
                        return nextState;
                    });
                    currentStep++; if (currentStep > 60) { clearInterval(simInterval); setIsSimulating(false); }
                }, 750);
            };

            return (
                <div className="flex flex-col min-h-screen bg-slate-50 text-slate-900 font-sans">
                    <header className="bg-white border-b border-slate-200 p-4 sticky top-0 z-50 shadow-sm backdrop-blur-md bg-white/80">
                        <div className="max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4">
                            <div className="flex items-center gap-3 group">
                                <div className="bg-blue-600 p-2.5 rounded-xl text-white shadow-lg"><UIIcon name="network" color="white" /></div>
                                <div><h1 className="text-xl font-black tracking-tight text-slate-800">Topologi Jaringan & Packet Switching</h1><p className="text-[10px] text-slate-400 font-bold uppercase tracking-[0.2em]"></p></div>
                            </div>
                            <nav className="flex bg-slate-100 p-1.5 rounded-2xl border border-slate-200">
                                {Object.values(MODES).map(mode => (
                                    <button key={mode} onClick={() => { setActiveMode(mode); setPackets([]); setIsSimulating(false); }}
                                        className={`px-6 py-2 rounded-xl text-xs font-black uppercase tracking-wider transition-all ${activeMode === mode ? 'bg-white text-blue-600 shadow-md scale-105' : 'text-slate-500 hover:text-slate-800'}`}>
                                        {mode}
                                    </button>
                                ))}
                            </nav>
                        </div>
                    </header>

                    <main className="flex-1 max-w-7xl mx-auto w-full p-4 md:p-8 grid grid-cols-1 lg:grid-cols-4 gap-8">
                        <div className="lg:col-span-1 space-y-6">
                            <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-200">
                                <h2 className="text-[10px] font-black text-slate-400 uppercase mb-5 tracking-[0.2em] flex items-center gap-2"><UIIcon name="zap" color="#eab308" /> Command Center</h2>
                                {activeMode === MODES.LAB ? (
                                    <div className="space-y-4">
                                        <div className="grid grid-cols-1 gap-2.5">
                                            {[{ id: TOPOLOGIES.BUS, icon: "activity", desc: 'Single Line Backbone' }, { id: TOPOLOGIES.STAR, icon: "share-2", desc: 'Centralized Hub' }, { id: TOPOLOGIES.RING, icon: "circle", desc: 'Loop Circuit' }, { id: TOPOLOGIES.MESH, icon: "grid", desc: 'Fault Tolerant' }].map(t => (
                                                <button key={t.id} onClick={() => { setTopology(t.id); setBrokenElements(new Set()); }}
                                                    className={`flex flex-col p-4 rounded-2xl border transition-all text-left ${topology === t.id ? 'bg-blue-600 border-blue-600 text-white shadow-xl' : 'border-slate-100 hover:border-blue-200 hover:bg-slate-50 text-slate-700'}`}>
                                                    <div className="flex items-center gap-2 font-black uppercase text-xs mb-1"><UIIcon name={t.icon} color={topology === t.id ? "white" : "currentColor"} /> {t.id}</div>
                                                    <span className={`text-[10px] ${topology === t.id ? 'text-blue-100' : 'text-slate-400'}`}>{t.desc}</span>
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                ) : (
                                    <div className="space-y-4">
                                        <div className="p-4 bg-slate-900 rounded-2xl text-white shadow-xl text-center">
                                            <div className="flex items-center justify-center gap-2 mb-3"><div className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div><span className="text-[10px] font-black uppercase tracking-wider text-green-400">Adaptive Engine Ready</span></div>
                                            <button onClick={startPacketSimulation} disabled={isSimulating}
                                                className="w-full flex items-center justify-center gap-2 bg-blue-500 hover:bg-blue-400 disabled:bg-slate-700 text-white py-4 rounded-xl font-black uppercase text-xs transition-all shadow-lg">
                                                <UIIcon name="play" color="white" /> Kirim 8 Paket
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>

                            <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-200">
                                 <h2 className="text-[10px] font-black text-slate-400 uppercase mb-4 tracking-[0.2em] flex items-center gap-2"><UIIcon name="activity" color="#3b82f6" /> Analysis Monitor</h2>
                                 <div className={`p-4 rounded-2xl flex flex-col gap-3 ${activeMode === MODES.LAB ? (isLabConnected() ? 'bg-green-50' : 'bg-red-50') : 'bg-blue-50'}`}>
                                        <div className="flex items-center gap-3">
                                            <UIIcon name={activeMode === MODES.LAB ? (isLabConnected() ? "check-circle-2" : "x-circle") : "activity"} color={activeMode === MODES.LAB ? (isLabConnected() ? "#16a34a" : "#dc2626") : "#2563eb"} size={24} />
                                            <div><p className={`font-black uppercase text-[10px] tracking-wider ${activeMode === MODES.LAB ? (isLabConnected() ? 'text-green-700' : 'text-red-700') : 'text-blue-700'}`}>
                                                {activeMode === MODES.LAB ? (isLabConnected() ? 'Link Active' : 'Offline') : 'Packet Tracking'}
                                            </p><p className="text-[9px] text-slate-500 mt-0.5">Path: Host A ⇄ Host B</p></div>
                                        </div>
                                 </div>
                                 {activeMode === MODES.PACKET && packets.length > 0 && (
                                     <div className="mt-4 max-h-[250px] overflow-y-auto space-y-2 pr-1 custom-scrollbar">
                                        {packets.map(p => (
                                            <div key={p.id} className="text-[10px] flex flex-col p-3 bg-slate-50 rounded-2xl border border-slate-100">
                                                <div className="flex justify-between mb-2 font-black text-slate-700 uppercase"><span>P#{p.id}</span><span className={`${p.status === 'arrived' ? 'text-green-600' : 'text-blue-500'}`}>{p.status}</span></div>
                                                <div className="flex gap-1.5 flex-wrap items-center opacity-60 font-bold">
                                                     {p.history.map((h, i) => (<React.Fragment key={i}><span>{h === 1 ? 'A' : h === 12 ? 'B' : `R${h-1}`}</span>{i < p.history.length - 1 && <span>→</span>}</React.Fragment>))}
                                                </div>
                                            </div>
                                        ))}
                                     </div>
                                 )}
                            </div>
                        </div>

                        <div className="lg:col-span-3 bg-white rounded-[2rem] shadow-xl border border-slate-200 relative overflow-hidden flex flex-col min-h-[550px]">
                            <div className="absolute top-8 left-8 z-10 hidden md:block">
                                 <div className="bg-white/80 backdrop-blur-md px-4 py-2 rounded-2xl border border-slate-200 shadow-sm flex items-center gap-2 text-xs font-bold text-slate-600">
                                     <UIIcon name="mouse-pointer-2" size={14} color="#3b82f6" /> Klik perangkat atau kabel untuk simulasi
                                 </div>
                            </div>
                            <div className="flex-1 w-full bg-[#fcfdfe]">
                                <svg viewBox="0 0 800 500" className="w-full h-full select-none">
                                    <defs>
                                        <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse"><path d="M 40 0 L 0 0 0 40" fill="none" stroke="#f1f5f9" strokeWidth="1"/></pattern>
                                        <filter id="node-shadow" x="-20%" y="-20%" width="140%" height="140%"><feDropShadow dx="0" dy="4" stdDeviation="6" floodOpacity="0.05" /></filter>
                                    </defs>
                                    <rect width="800" height="500" fill="url(#grid)" />

                                    {activeMode === MODES.LAB && (
                                        <g>
                                            {/* Static Lines Layer */}
                                            {topology === TOPOLOGIES.BUS && (
                                                <line x1="100" y1="200" x2="700" y2="200" stroke={brokenElements.has('backbone') ? '#ef4444' : '#3b82f6'} strokeWidth="8" strokeLinecap="round" className="cursor-pointer" onClick={() => {const n = new Set(brokenElements); n.has('backbone') ? n.delete('backbone') : n.add('backbone'); setBrokenElements(n); }} />
                                            )}
                                            {topologyData.edges.map(edge => {
                                                if (edge.isBackboneSeg) return null;
                                                const from = edge.from.startsWith('bus') ? { x: edge.busX, y: 200 } : topologyData.nodes.find(n => n.id === edge.from);
                                                const to = topologyData.nodes.find(n => n.id === edge.to);
                                                const isBroken = brokenElements.has(edge.id) || (topology === TOPOLOGIES.BUS && brokenElements.has('backbone'));
                                                return (
                                                    <line key={edge.id} x1={from.x} y1={from.y} x2={to.x} y2={to.y} stroke={isBroken ? '#fee2e2' : '#dbeafe'} strokeWidth="10" strokeLinecap="round" className="cursor-pointer" onClick={() => {const n = new Set(brokenElements); n.has(edge.id) ? n.delete(edge.id) : n.add(edge.id); setBrokenElements(n); }} />
                                                );
                                            })}

                                            {/* Data Flow Layer (Glowing Cyan) - Rendered on Top */}
                                            <g id="data-flow-layer">
                                                {isLabConnected() && topology === TOPOLOGIES.BUS && !brokenElements.has('backbone') && (
                                                    <line x1="100" y1="200" x2="700" y2="200" className="data-flow-line" />
                                                )}
                                                {isLabConnected() && topologyData.edges.map(edge => {
                                                    if (edge.isBackboneSeg) return null;
                                                    const from = edge.from.startsWith('bus') ? { x: edge.busX, y: 200 } : topologyData.nodes.find(n => n.id === edge.from);
                                                    const to = topologyData.nodes.find(n => n.id === edge.to);
                                                    const isBroken = brokenElements.has(edge.id) || (topology === TOPOLOGIES.BUS && brokenElements.has('backbone'));
                                                    return !isBroken && (
                                                        <line key={`flow-${edge.id}`} x1={from.x} y1={from.y} x2={to.x} y2={to.y} className="data-flow-line" />
                                                    );
                                                })}
                                            </g>

                                            {/* Nodes Layer */}
                                            {topologyData.nodes.filter(n => !n.isBackbone).map(node => {
                                                const isA = node.id === 'n0'; const isB = node.id === 'n1';
                                                const isBroken = brokenElements.has(node.id);
                                                const badgeY = (topology === TOPOLOGIES.BUS && node.y < 200) ? -65 : (topology === TOPOLOGIES.BUS ? 65 : -65);
                                                return (
                                                    <g key={node.id} transform={`translate(${node.x},${node.y})`} className="cursor-pointer" onClick={() => {const n = new Set(brokenElements); n.has(node.id) ? n.delete(node.id) : n.add(node.id); setBrokenElements(n); }}>
                                                        {(isA || isB) && (
                                                            <g transform={`translate(0, ${badgeY})`}>
                                                                <rect x="-35" y="-12" width="70" height="22" rx="11" fill={isA ? '#3b82f6' : '#6366f1'} />
                                                                <text dy="2" textAnchor="middle" fill="white" className="text-[9px] font-black uppercase tracking-wider">{isA ? 'Sender' : 'Receiver'}</text>
                                                            </g>
                                                        )}
                                                        <circle r="36" fill="white" stroke={isBroken ? '#ef4444' : (isA || isB ? (isA ? '#3b82f6' : '#6366f1') : '#cbd5e1')} strokeWidth={isA || isB ? 3 : 2} filter="url(#node-shadow)" />
                                                        <g transform="translate(-14, -20)"><HardwareIcon type={node.type} color={isBroken ? '#ef4444' : (isA || isB ? (isA ? '#3b82f6' : '#6366f1') : '#64748b')} /></g>
                                                        <text y="16" textAnchor="middle" className={`text-[11px] font-black uppercase tracking-tighter ${isBroken ? 'fill-red-500' : 'fill-slate-600'}`}>{node.label}</text>
                                                        {isBroken && (<g transform="translate(18, -26)"><circle r="10" fill="white" stroke="#ef4444" strokeWidth="1" /><UIIcon name="x-circle" color="#ef4444" size={16} /></g>)}
                                                    </g>
                                                );
                                            })}
                                        </g>
                                    )}

                                    {activeMode === MODES.PACKET && (
                                        <g>
                                            {/* Static Mesh Lines */}
                                            {packetEdges.map((edge, idx) => {
                                                const from = packetNodes.find(n => n.id === edge.from); const to = packetNodes.find(n => n.id === edge.to);
                                                const active = routerStatus[edge.from] && routerStatus[edge.to];
                                                return (
                                                    <g key={idx}>
                                                        <line x1={from.x} y1={from.y} x2={to.x} y2={to.y} stroke={active ? '#dbeafe' : '#e2e8f0'} strokeWidth={active ? 4 : 2} opacity={active ? 1 : 0.2} />
                                                        {active && isSimulating && (
                                                            <line x1={from.x} y1={from.y} x2={to.x} y2={to.y} className="data-flow-line" style={{strokeWidth: 2}} />
                                                        )}
                                                    </g>
                                                );
                                            })}
                                            {/* Packet Nodes */}
                                            {packetNodes.map(node => {
                                                const active = routerStatus[node.id];
                                                const isA = node.id === 1; const isB = node.id === 12;
                                                const load = routerLoad[node.id] || 0;
                                                return (
                                                    <g key={node.id} transform={`translate(${node.x},${node.y})`} className="cursor-pointer" onClick={() => toggleRouter(node.id)}>
                                                        {(isA || isB) && (<g transform="translate(0, -52)"><rect x="-30" y="-12" width="60" height="20" rx="10" fill={isA ? '#3b82f6' : '#6366f1'} /><text dy="2" textAnchor="middle" fill="white" className="text-[8px] font-black uppercase tracking-widest">{isA ? 'Source' : 'Dest'}</text></g>)}
                                                        <circle r="32" fill="white" stroke={active ? (isA || isB ? (isA ? '#3b82f6' : '#6366f1') : (load > 0 ? '#3b82f6' : '#e2e8f0')) : '#f43f5e'} strokeWidth={isA || isB ? 3 : 2} filter="url(#node-shadow)" />
                                                        <g transform="translate(-13, -18)"><HardwareIcon type={node.type} color={active ? (isA || isB ? (isA ? '#3b82f6' : '#6366f1') : '#64748b') : '#f43f5e'} size={26} /></g>
                                                        <text y="14" textAnchor="middle" className={`text-[10px] font-black uppercase tracking-widest ${active ? 'fill-slate-500' : 'fill-red-400'}`}>{node.label}</text>
                                                        {!active && (<g transform="translate(16, -22)"><circle r="9" fill="white" stroke="#ef4444" /><UIIcon name="x-circle" color="#ef4444" size={14} /></g>)}
                                                    </g>
                                                );
                                            })}
                                            {/* Packets */}
                                            {packets.map(p => {
                                                if (p.status === 'queued') return null;
                                                const pkInNode = packets.filter(pk => pk.currentPos.id === p.currentPos.id && pk.status === p.status);
                                                const myIdx = pkInNode.indexOf(p);
                                                const offsetX = (myIdx % 3) * 14 - 14; const offsetY = Math.floor(myIdx / 3) * 14 - 14;
                                                return (
                                                    <g key={p.id} transform={`translate(${p.currentPos.x + offsetX},${p.currentPos.y + offsetY})`} className="packet-transition">
                                                        <rect x="-8" y="-8" width="16" height="16" rx="4" fill={p.status === 'arrived' ? '#10b981' : p.status === 'dropped' ? '#ef4444' : '#2563eb'} />
                                                        <text dy="3" textAnchor="middle" fill="white" className="text-[9px] font-black">{p.id}</text>
                                                    </g>
                                                );
                                            })}
                                        </g>
                                    )}
                                </svg>
                            </div>
                        </div>
                    </main>

                    {/* DYNAMIC FOOTER (Materi Singkat) */}
                    <footer className="max-w-7xl mx-auto w-full px-4 pb-12 mt-4">
                        <div className="bg-white rounded-[2rem] p-8 shadow-sm border border-slate-200">
                            <div className="space-y-4 text-slate-600">
                                <div className="flex items-center gap-3">
                                    <div className="bg-blue-100 p-3 rounded-2xl text-blue-600">
                                        <UIIcon name={activeMode === MODES.LAB ? "network" : "layers"} size={28} />
                                    </div>
                                    <h3 className="text-xl font-black text-slate-800 uppercase tracking-tight">
                                        Materi Singkat: {activeMode === MODES.LAB ? "Topologi Jaringan" : "Packet Switching"}
                                    </h3>
                                </div>
                                {activeMode === MODES.LAB ? (
                                    <div className="space-y-3 text-sm leading-relaxed font-medium">
                                        <p><strong>Topologi Jaringan</strong> menentukan struktur fisik dan logis perangkat saling terhubung. Perhatikan <strong>garis putus-putus Cyan</strong> yang muncul di atas kabel; itu melambangkan jalur data yang aktif mengalir dari Host A ke Host B.</p>
                                        <ul className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-2 list-disc pl-5">
                                            <li><span className="font-bold text-slate-800 text-xs uppercase">Bus:</span> Kabel tunggal (backbone). Kerusakan kabel utama memutus seluruh sistem.</li>
                                            <li><span className="font-bold text-slate-800 text-xs uppercase">Star:</span> HUB pusat. HUB rusak memutus semua titik.</li>
                                            <li><span className="font-bold text-slate-800 text-xs uppercase">Ring:</span> Sirkuit tertutup. Satu titik gagal memutus lingkaran.</li>
                                            <li><span className="font-bold text-slate-800 text-xs uppercase">Mesh:</span> Banyak rute alternatif. Redundansi tertinggi.</li>
                                        </ul>
                                    </div>
                                ) : (
                                    <div className="space-y-3 text-sm leading-relaxed font-medium text-center">
                                        <p><strong>Packet Switching</strong> adalah metode pengiriman di mana data dipecah menjadi <strong>Paket</strong>. Setiap paket mencari rute secara mandiri.</p>
                                        <div className="bg-blue-50 p-4 rounded-2xl border border-blue-100 italic text-blue-800 text-xs inline-block mx-auto">
                                            "Simulator ini menggunakan <strong>Adaptive OSPF Logic</strong>: Garis Cyan menunjukkan jalur yang dipilih paket untuk menghindari router yang sibuk atau mati."
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>